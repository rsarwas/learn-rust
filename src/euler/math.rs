/// Each new term in the Fibonacci sequence is generated by adding the previous two terms.
/// By starting with 1 and 2, the first 10 terms will be:
///    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
///
/// The common definitions (per wikipedia) start with 0, 1
///   0, 1, 1, 2, 3, 5, 8, ...
pub mod fibonacci {

    // Fibonacci by index number where f(0) -> 0, fib(1) -> 1, ...
    // Typical recursive solution, inefficient due to redundant calculations
    // i.e. fib(5) calculates fib(3) and fib(4), fib(4) then recalculates fib(3)
    pub fn fib(n: usize) -> usize {
        if n == 0 { return 0 }
        if n == 1 { return 1 }
        fib(n-1) + fib(n-2)
    }


    // Fibonacci by index number where f(0) -> 0, fib(1) -> 1, ...
    // A more efficient counting solution for a specific number,
    // but the sequence leading upto the solution is lost
	pub fn fibonacci(n : usize) -> usize {
        if n == 0 { return 0 }
        if n == 1 { return 1 }
        let mut x = (0, 1);
        for _ in 1..n {
            x = (x.1, x.0 + x.1)
        }
        x.1
    }

    // Fibonacci sequence with N elements as a vector
    // as fast as the loop method but consumes more memory
    // vector allocation is faster and more efficient, because we know
    // how many elements there are
	pub fn fibonacci_first(n : usize) -> Vec<usize> {
        let mut v = Vec::with_capacity(n);
        for i in 0..n {
            if i < 2 {
                v.push(i);
            } else {
                v.push(v[i-1] + v[i-2]);
            }
        }
        v
    }

    // Fibonacci sequence as a vector with all numbers upto N
    // as fast as the loop method but consumes more memory
    // vector allocation is faster and more efficient, because we know
    // how many elements there are
    pub fn fibonacci_upto(n : usize) -> Vec<usize> {
        let mut v = Vec::new();
        v.push(0);
        if n == 0 { return v };
        v.push(1);
        if n == 1 { return v };
        for i in 2.. {
            let x = v[i-1] + v[i-2];
            if x > n { break; };
            v.push(x);
        }
        v
    }

    // Fibonacci series as an infite iterator
    // This should be as fast as the loop method, and use very little memory
    // Until Generators are in the stable release of rust, I will need a
    // struct to hold the state (last two numbers),
    // and implment the Iterator trait
    pub struct Fib {
        x : (usize, usize)
    }

    impl Fib {
        fn new() -> Fib {
            Fib { x: (0, 1) }
        }
    }

    impl Iterator for Fib {
        type Item = usize;
        fn next(&mut self) -> Option<usize> {
            let next = self.x.0 + self.x.1;
            self.x = (self.x.1, next);
            Some(next)
        }
    }

    pub fn iter() -> Fib {
        Fib::new()
    }

    // Benchmark results
    // recursive solution is horrible
    // loop solution is very fast if you only need one number
    // iterator is the next best solution at about < 20ns per number
    // The vector based solutions were about the same ~ 10Âµs for 20 elements (~50ns each)

    #[allow(dead_code)]
    pub fn benchmark() {
        println!("Recursive solution for specific fibonacci number");
        for i in 1..20 {
            let start = std::time::Instant::now();
            println!("fib #{} = {} in {:?}", i, fib(i), start.elapsed());
        }
        println!("Loop solution for specific fibonacci number");
        for i in 1..20 {
            let start = std::time::Instant::now();
            println!("fib #{} = {} in {:?}", i, fibonacci(i), start.elapsed());
        }
        println!("Create a vector of the first 20 fibonacci numbers");
        let start = std::time::Instant::now();
        let fibs = fibonacci_first(20);
        println!(" created in {:?}", start.elapsed());
        for (i, f) in fibs.iter().enumerate() {
            println!("fib #{} = {}", i, f);
        }
        println!("Create a vector of the fibonacci numbers upto 10,000");
        let start = std::time::Instant::now();
        let fibs = fibonacci_upto(10_000);
        println!(" created in {:?}", start.elapsed());
        for (i, f) in fibs.iter().enumerate() {
            println!("fib #{} = {}", i, f);
        }
        println!("Iterator solution");
        let mut start = std::time::Instant::now();
        for (i, f) in iter().take(20).enumerate() {
            println!("fib #{} = {} in {:?}", i, f, start.elapsed());
            start = std::time::Instant::now();
        }
    }
}
