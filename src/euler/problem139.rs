//! Pythagorean tiles
//!
//! Let (a, b, c) represent the three sides of a right angle triangle with integral length sides.
//! It is possible to place four such triangles together to form a square with length c.
//!
//! For example, (3, 4, 5) triangles can be placed together to form a 5 by 5 square with a
//! 1 by 1 hole in the middle and it can be seen that the 5 by 5 square can be tiled with
//! twenty-five 1 by 1 squares.
//!
//! {diagram elided}
//!
//! However, if (5, 12, 13) triangles were used then the hole would measure 7 by 7 and these
//! could not be used to tile the 13 by 13 square.
//!
//! Given that the perimeter of the right triangle is less than one-hundred million,
//! how many Pythagorean triangles would allow such a tiling to take place?

/// Problem 139
///
/// Given that the perimeter of the right triangle is less than one-hundred million,
/// how many Pythagorean triangles would allow such a tiling to take place?
pub fn answer() -> u64 {
    option1(100_000_000) as u64
}

/// Problem 139 (Test Sample)
///
/// Number of "tile-able" triangles are there with a perimeter < 1000
#[allow(dead_code)]
pub fn sample() {
    println!("{} with a+b+c < 1000", option1(1000));
}

/// Returns the number of "tile-able" pythagorean triangles with perimeter < n
///
/// We generate a list of primative pythagorean triples using Euclid's formula
/// for an arbitrary pair of integers m and n with m > n > 0. The formula states that the integers
///
///     a = m^2-n^2,  b = 2mn,  c = m^2+n^2
///
/// form a Pythagorean triple. The triple generated by Euclid's formula is primitive if and
/// only if m and n are coprime and not both odd. When both m and n are odd, then a, b, and c
/// will be even, and the triple will not be primitive; however, dividing a, b, and c by 2
/// will yield a primitive triple when m and n are coprime and both odd.
///
/// Since we are only getting primatives, we also need to count all multiples of the primative
/// i.e. since 3,4,5 works, 6,8,10 also works.
///
/// Uncomment the println! statements to see which triples are being tested.  Useful for testing.
pub fn option1(a_b_c: usize) -> usize {
    let mut total = 0;
    // a + b + c = (m^2 - n^2) + 2mn + (m^2 + n^2) = 2m^2 + 2mn = 2m(m+n)
    for m in 2.. {
        let m2 = m * m;
        let perim = 2 * (m2 + m); // assuming n = 1
        if perim > a_b_c {
            break;
        }
        for n in 1..m {
            //println!("(m,n) = ({},{})", m, n);
            let perim = 2 * (m2 + m * n);
            if perim > a_b_c {
                break;
            }
            let odd = (m - n) % 2 == 1;
            if odd && num_integer::gcd(m, n) == 1 {
                // primative pythagorean triple
                let n2 = n * n;
                let a = m2 - n2;
                let b = 2 * m * n;
                let c = m2 + n2;
                //println!("Right triangle {},{},{}", a, b, c);
                let hole_size;
                if a > b {
                    hole_size = a - b;
                } else {
                    hole_size = b - a;
                }
                if c % hole_size == 0 {
                    // This triple and all multiples satisfy the problem
                    let count = a_b_c / perim;
                    total += count;
                    //println!("   {} hole paves square!", count)
                }
            }
        }
    }
    total
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn sum_of_digits_test1() {
        assert_eq!(option1(100), 9);
    }
}
