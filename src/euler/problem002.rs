//! Even Fibonacci numbers
//!
//! Each new term in the Fibonacci sequence is generated by adding the previous two terms.
//! By starting with 1 and 2, the first 10 terms will be:
//!    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
//! By considering the terms in the Fibonacci sequence whose values do not
//! exceed four million, find the sum of the even-valued terms.

use super::math::fibonacci;

/// Euler Problem # 2
///
/// Find the sum of the even Fibonacci numbers not exceeding four million.
pub fn answer() -> u64 {
    option3(4_000_000) as u64
}

/// Euler Problem # 2 (Test Sample)
///
/// Find the sum of the even Fibonacci numbers not exceeding 89.
/// This prints the fibonacci series, then just the even terms,
/// so that we can visually verify the answer for a simple case.
#[allow(dead_code)]
pub fn sample() {
    println!("Fibonnaci numbers that do not exceed 89:");
    for f in fibonacci::iter().take_while(|x| *x <= 89) {
        print!(" {}", f);
    }
    println!("\nEven fibonnaci numbers that do not exceed 89");
    for f in fibonacci::iter()
        .take_while(|x| *x <= 89)
        .filter(|x| x % 2 == 0)
    {
        print!(" {}", f);
    }
    println!("\nSum of even fibonnaci numbers that do not exceed 89");
    println!("  Option #1 {}", option1(89));
    println!("  Option #2 {}", option2(89));
    println!("  Option #3 {}", option3(89));
}

// See the fibonacci module for benchmarking of the fibonacci methods

/// Sum of even Fibonacci numbers upto n
///
/// Option #1:  Solve with an infinite fibonnaci iterator
/// with release build, this takes about 100ns
///
/// # Examples
///
/// ```
/// let answer = option1(89);
/// asert_eq!(answer, 44);
/// ```
pub fn option1(n: usize) -> usize {
    fibonacci::iter2()
        .take_while(|x| *x <= n)
        .filter(|x| x % 2 == 0)
        .sum()
}

/// Sum of even Fibonacci numbers upto n
///
/// Option #2:  Solve with a vector of Fibonacci terms
/// This is much slower than the iterator solution
/// with release build, this takes about 40Âµs
///
/// # Examples
///
/// ```
/// let answer = option1(89);
/// asert_eq!(answer, 44);
/// ```
pub fn option2(n: usize) -> usize {
    let mut sum = 0;
    for f in fibonacci::fibonacci_upto(n).iter() {
        if f % 2 == 0 {
            sum += f;
        }
    }
    sum
}

/// Sum of even Fibonacci numbers upto n
///
/// Option #3:  Solve by doing testing and summing in the fibonacci generator
/// Surprisingly, this is no faster than the iterator solution
///
/// # Examples
///
/// ```
/// let answer = option1(89);
/// asert_eq!(answer, 44);
/// ```
pub fn option3(n: usize) -> usize {
    let mut sum = 2;
    let mut x = (3, 5);
    loop {
        let next = x.0 + x.1;
        if next > n {
            break;
        };
        if next % 2 == 0 {
            sum += next;
        };
        x = (x.1, next);
    }
    sum
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_iterator() {
        assert_eq!(option1(100), 44);
    }
    #[test]
    pub fn test_vector() {
        assert_eq!(option2(100), 44);
    }
    #[test]
    pub fn test_loop() {
        assert_eq!(option3(100), 44);
    }
}
